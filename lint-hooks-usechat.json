[{"filePath":"D:\\Taliyo Tech\\sample\\sample 7 august\\GoalTracker AI\\src\\react-app\\hooks\\useChat.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":147,"column":40,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":147,"endColumn":65,"fix":{"range":[4512,4526],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":198,"column":36,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":198,"endColumn":62,"fix":{"range":[6395,6409],"text":""}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { useRef, useState } from \"react\";\nimport toast from \"react-hot-toast\";\n\ninterface QuickAIResponse {\n  response?: unknown;\n  error?: unknown;\n}\ninterface ConversationResponse {\n  conversation?: { id?: unknown } | null;\n  error?: unknown;\n}\n\nfunction extractErrorMessage(data: unknown, fallback: string): string {\n  if (data && typeof data === \"object\" && \"error\" in data) {\n    const err = (data as { error?: unknown }).error;\n    if (typeof err === \"string\") return err;\n  }\n  return fallback;\n}\n\nfunction extractReply(data: unknown): string | null {\n  if (data && typeof data === \"object\" && \"response\" in data) {\n    const r = (data as QuickAIResponse).response;\n    if (typeof r === \"string\") return r;\n  }\n  return null;\n}\n\nfunction extractConversationId(data: unknown): number | null {\n  if (data && typeof data === \"object\" && \"conversation\" in data) {\n    const conv = (data as ConversationResponse).conversation;\n    const id =\n      conv && typeof conv === \"object\"\n        ? (conv as { id?: unknown }).id\n        : undefined;\n    if (typeof id === \"number\") return id;\n  }\n  return null;\n}\n\ninterface SendOptions {\n  onToken?: (t: string) => void;\n  regenerate?: boolean;\n}\n\nexport function useChat(): {\n  loading: boolean;\n  error: string | null;\n  sendMessage: (message: string, options?: SendOptions) => Promise<string>;\n  conversationId: number | null;\n  resetConversation: () => void;\n  stop: () => void;\n  selectConversation: (id: number) => void;\n} {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [conversationId, setConversationId] = useState<number | null>(null);\n  const controllerRef = useRef<AbortController | null>(null);\n\n  const resetConversation = (): void => {\n    setConversationId(null);\n  };\n  const selectConversation = (id: number): void => {\n    setConversationId(id);\n  };\n\n  const ensureConversation = async (): Promise<number | null> => {\n    if (conversationId) return conversationId;\n    try {\n      const res = await fetch(\"/api/chat/conversations\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ title: \"\" }),\n      });\n      if (res.status === 401) return null; // unauthenticated -> fall back to quick chat\n      if (!res.ok) {\n        let j: unknown = null;\n        try {\n          j = await res.json();\n        } catch {\n          /* ignore json parse errors */\n        }\n        const msg = extractErrorMessage(j, \"Failed to start conversation\");\n        throw new Error(msg);\n      }\n      let data: unknown = null;\n      try {\n        data = await res.json();\n      } catch {\n        /* ignore json parse errors */\n      }\n      const id = extractConversationId(data);\n      if (typeof id === \"number\") {\n        setConversationId(id);\n        return id;\n      }\n      return null;\n    } catch {\n      // Non-fatal: fall back to quick chat\n      return null;\n    }\n  };\n\n  const sendMessage = async (\n    message: string,\n    options?: SendOptions,\n  ): Promise<string> => {\n    try {\n      setLoading(true);\n      setError(null);\n      // Cancel any previous in-flight request\n      if (controllerRef.current) {\n        try {\n          controllerRef.current.abort();\n        } catch { /* ignore abort errors */ }\n      }\n      controllerRef.current = new AbortController();\n      const signal = controllerRef.current.signal;\n      // Try persistent chat first (if authenticated)\n      const convId = await ensureConversation();\n      if (convId) {\n        // Prefer SSE streaming for authenticated conversation\n        try {\n          const res = await fetch(\n            `/api/chat/${String(convId)}/messages/stream`,\n            {\n              method: \"POST\",\n              headers: { \"Content-Type\": \"application/json\" },\n              body: JSON.stringify({\n                content: message,\n                regenerate: !!options?.regenerate,\n              }),\n              signal,\n            },\n          );\n          if (res.status === 401 || res.status === 403) {\n            // Fall back to quick chat streaming\n          } else {\n            if (!res.ok || !res.body)\n              throw new Error(\"Streaming not available\");\n            const reader = res.body.getReader();\n            const decoder = new TextDecoder();\n            let buffer = \"\";\n            let full = \"\";\n            let chunk = await reader.read();\n            while (!chunk.done) {\n              buffer += decoder.decode(chunk.value as Uint8Array, { stream: true });\n              let idx;\n              while ((idx = buffer.indexOf(\"\\n\\n\")) !== -1) {\n                const evt = buffer.slice(0, idx);\n                buffer = buffer.slice(idx + 2);\n                if (evt.startsWith(\"event: done\")) {\n                  // end of stream\n                  reader.cancel().catch(() => {\n                    /* swallow cancel error */\n                  });\n                  buffer = \"\";\n                  break;\n                }\n                const lines = evt.split(\"\\n\");\n                for (const line of lines) {\n                  if (line.startsWith(\"data: \")) {\n                    const piece = line.slice(6);\n                    full += piece;\n                    if (piece) options?.onToken?.(piece);\n                  }\n                }\n              }\n              chunk = await reader.read();\n            }\n            const text = full.trim();\n            if (text.length > 0) return text;\n            throw new Error(\"Empty stream\");\n          }\n        } catch {\n          // If aborted, return empty string (UI retains whatever was appended via onToken)\n          if (signal.aborted) {\n            return \"\";\n          }\n        }\n      }\n\n      // Quick chat fallback (no auth or failure): try SSE streaming via /api/ai/stream\n      try {\n        const res = await fetch(\"/api/ai/stream\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ prompt: message }),\n          signal,\n        });\n        if (!res.ok || !res.body) throw new Error(\"Streaming not available\");\n        const reader = res.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = \"\";\n        let full = \"\";\n        let chunk2 = await reader.read();\n        while (!chunk2.done) {\n          buffer += decoder.decode(chunk2.value as Uint8Array, { stream: true });\n          let idx;\n          while ((idx = buffer.indexOf(\"\\n\\n\")) !== -1) {\n            const evt = buffer.slice(0, idx);\n            buffer = buffer.slice(idx + 2);\n            if (evt.startsWith(\"event: done\")) {\n              // end of stream\n              break;\n            }\n            const lines = evt.split(\"\\n\");\n            for (const line of lines) {\n              if (line.startsWith(\"data: \")) {\n                const piece = line.slice(6);\n                full += piece;\n                if (piece) options?.onToken?.(piece);\n              }\n            }\n          }\n          chunk2 = await reader.read();\n        }\n        const text = full.trim();\n        if (text.length > 0) return text;\n        throw new Error(\"Empty stream\");\n      } catch {\n        // If aborted, return empty string instead of throwing a toast error\n        if (signal.aborted) {\n          return \"\";\n        }\n        // Fallback to non-streaming JSON endpoint\n        const quick = await fetch(\"/api/ai\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ prompt: message }),\n        });\n        if (!quick.ok) {\n          let j: unknown = null;\n          try {\n            j = await quick.json();\n          } catch { /* ignore json parse errors */ }\n          const msg = extractErrorMessage(j, \"Failed to send message\");\n          throw new Error(msg);\n        }\n        let data: unknown = null;\n        try {\n          data = await quick.json();\n        } catch {\n          /* ignore json parse errors */\n        }\n        const reply = extractReply(data);\n        if (typeof reply === \"string\") {\n          if (reply) options?.onToken?.(reply);\n          return reply;\n        }\n        throw new Error(\"Invalid response\");\n      }\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to send message\";\n      setError(errorMessage);\n      toast.error(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const stop = (): void => {\n    if (controllerRef.current) {\n      try {\n        controllerRef.current.abort();\n      } catch {\n        /* ignore abort error */\n      }\n      controllerRef.current = null;\n      setLoading(false);\n    }\n  };\n\n  return {\n    loading,\n    error,\n    sendMessage,\n    conversationId,\n    resetConversation,\n    stop,\n    selectConversation,\n  };\n}\n","usedDeprecatedRules":[]}]