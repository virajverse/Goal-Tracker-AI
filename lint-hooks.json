[{"filePath":"D:\\Taliyo Tech\\sample\\sample 7 august\\GoalTracker AI\\src\\react-app\\hooks\\useAISuggestions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\Taliyo Tech\\sample\\sample 7 august\\GoalTracker AI\\src\\react-app\\hooks\\useAnalytics.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"number\" of template literal expression.","line":71,"column":41,"nodeType":"Identifier","messageId":"invalidType","endLine":71,"endColumn":45}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from \"react\";\n\ninterface ProgressData {\n  log_date: string;\n  total_tasks: number;\n  completed_tasks: number;\n  completion_rate: number;\n}\n\ninterface GoalStats {\n  id: number;\n  title: string;\n  category: string;\n  target_frequency: string;\n  total_logs: number;\n  completed_count: number;\n  completion_rate: number;\n}\n\ninterface ProgressResponseJson {\n  progress?: ProgressData[];\n  error?: unknown;\n}\ninterface GoalStatsResponseJson {\n  goalStats?: GoalStats[];\n  error?: unknown;\n}\n\nfunction extractErrorMessage(data: unknown, fallback: string): string {\n  if (data && typeof data === \"object\" && \"error\" in data) {\n    const err = (data as { error?: unknown }).error;\n    if (typeof err === \"string\") return err;\n  }\n  return fallback;\n}\n\nfunction extractProgress(data: unknown): ProgressData[] {\n  if (data && typeof data === \"object\" && \"progress\" in data) {\n    const p = (data as ProgressResponseJson).progress;\n    if (Array.isArray(p)) return p;\n  }\n  return [];\n}\n\nfunction extractGoalStats(data: unknown): GoalStats[] {\n  if (data && typeof data === \"object\" && \"goalStats\" in data) {\n    const g = (data as GoalStatsResponseJson).goalStats;\n    if (Array.isArray(g)) return g;\n  }\n  return [];\n}\n\nexport function useAnalytics(days = 30): {\n  progressData: ProgressData[];\n  goalStats: GoalStats[];\n  loading: boolean;\n  error: string | null;\n  refetch: () => Promise<void>;\n} {\n  const [progressData, setProgressData] = useState<ProgressData[]>([]);\n  const [goalStats, setGoalStats] = useState<GoalStats[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchAnalytics = useCallback(async (): Promise<void> => {\n    try {\n      setLoading(true);\n\n      // Fetch progress data\n      const progressResponse = await fetch(\n        `/api/analytics/progress?days=${days}`,\n      );\n      if (!progressResponse.ok) {\n        let pdata: unknown = null;\n        try {\n          pdata = await progressResponse.json();\n        } catch {\n          /* ignore json parse errors */\n        }\n        const msg = extractErrorMessage(pdata, \"Failed to fetch progress data\");\n        throw new Error(msg);\n      }\n      let pjson: unknown = null;\n      try {\n        pjson = await progressResponse.json();\n      } catch {\n        /* ignore json parse errors */\n      }\n      setProgressData(extractProgress(pjson));\n\n      // Fetch goal statistics\n      const goalsResponse = await fetch(\"/api/analytics/goals\");\n      if (!goalsResponse.ok) {\n        let gdata: unknown = null;\n        try {\n          gdata = await goalsResponse.json();\n        } catch {\n          /* ignore json parse errors */\n        }\n        const msg = extractErrorMessage(\n          gdata,\n          \"Failed to fetch goal statistics\",\n        );\n        throw new Error(msg);\n      }\n      let gjson: unknown = null;\n      try {\n        gjson = await goalsResponse.json();\n      } catch {\n        /* ignore json parse errors */\n      }\n      setGoalStats(extractGoalStats(gjson));\n\n      setError(null);\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to fetch analytics\";\n      setError(errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  }, [days]);\n\n  useEffect(() => {\n    void fetchAnalytics();\n  }, [fetchAnalytics]);\n\n  return {\n    progressData,\n    goalStats,\n    loading,\n    error,\n    refetch: fetchAnalytics,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Taliyo Tech\\sample\\sample 7 august\\GoalTracker AI\\src\\react-app\\hooks\\useChat.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":98,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":98,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":145,"column":20,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":145,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":175,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":175,"endColumn":19},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":177,"column":15,"nodeType":"MemberExpression","messageId":"alwaysTruthy","endLine":177,"endColumn":36},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":177,"column":15,"nodeType":null,"messageId":"preferOptionalChain","endLine":177,"endColumn":76,"suggestions":[{"fix":{"range":[5652,5713],"text":"controllerRef.current?.signal.aborted"},"messageId":"optionalChainSuggest","desc":"Change to an optional chain."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":196,"column":16,"nodeType":"Literal","messageId":"alwaysTruthy","endLine":196,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":221,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":221,"endColumn":17}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useState } from \"react\";\nimport toast from \"react-hot-toast\";\n\ninterface QuickAIResponse {\n  response?: unknown;\n  error?: unknown;\n}\ninterface ConversationResponse {\n  conversation?: { id?: unknown } | null;\n  error?: unknown;\n}\n\nfunction extractErrorMessage(data: unknown, fallback: string): string {\n  if (data && typeof data === \"object\" && \"error\" in data) {\n    const err = (data as { error?: unknown }).error;\n    if (typeof err === \"string\") return err;\n  }\n  return fallback;\n}\n\nfunction extractReply(data: unknown): string | null {\n  if (data && typeof data === \"object\" && \"response\" in data) {\n    const r = (data as QuickAIResponse).response;\n    if (typeof r === \"string\") return r;\n  }\n  return null;\n}\n\nfunction extractConversationId(data: unknown): number | null {\n  if (data && typeof data === \"object\" && \"conversation\" in data) {\n    const conv = (data as ConversationResponse).conversation;\n    const id =\n      conv && typeof conv === \"object\"\n        ? (conv as { id?: unknown }).id\n        : undefined;\n    if (typeof id === \"number\") return id;\n  }\n  return null;\n}\n\ninterface SendOptions {\n  onToken?: (t: string) => void;\n  regenerate?: boolean;\n}\n\nexport function useChat(): {\n  loading: boolean;\n  error: string | null;\n  sendMessage: (message: string, options?: SendOptions) => Promise<string>;\n  conversationId: number | null;\n  resetConversation: () => void;\n  stop: () => void;\n  selectConversation: (id: number) => void;\n} {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [conversationId, setConversationId] = useState<number | null>(null);\n  const controllerRef = useRef<AbortController | null>(null);\n\n  const resetConversation = (): void => {\n    setConversationId(null);\n  };\n  const selectConversation = (id: number): void => {\n    setConversationId(id);\n  };\n\n  const ensureConversation = async (): Promise<number | null> => {\n    if (conversationId) return conversationId;\n    try {\n      const res = await fetch(\"/api/chat/conversations\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ title: \"\" }),\n      });\n      if (res.status === 401) return null; // unauthenticated -> fall back to quick chat\n      if (!res.ok) {\n        let j: unknown = null;\n        try {\n          j = await res.json();\n        } catch {\n          /* ignore json parse errors */\n        }\n        const msg = extractErrorMessage(j, \"Failed to start conversation\");\n        throw new Error(msg);\n      }\n      let data: unknown = null;\n      try {\n        data = await res.json();\n      } catch {\n        /* ignore json parse errors */\n      }\n      const id = extractConversationId(data);\n      if (typeof id === \"number\") {\n        setConversationId(id);\n        return id;\n      }\n      return null;\n    } catch (e) {\n      // Non-fatal: fall back to quick chat\n      return null;\n    }\n  };\n\n  const sendMessage = async (\n    message: string,\n    options?: SendOptions,\n  ): Promise<string> => {\n    try {\n      setLoading(true);\n      setError(null);\n      // Cancel any previous in-flight request\n      if (controllerRef.current) {\n        try {\n          controllerRef.current.abort();\n        } catch { /* ignore abort errors */ }\n      }\n      controllerRef.current = new AbortController();\n      const signal = controllerRef.current.signal;\n      // Try persistent chat first (if authenticated)\n      const convId = await ensureConversation();\n      if (convId) {\n        // Prefer SSE streaming for authenticated conversation\n        try {\n          const res = await fetch(\n            `/api/chat/${String(convId)}/messages/stream`,\n            {\n              method: \"POST\",\n              headers: { \"Content-Type\": \"application/json\" },\n              body: JSON.stringify({\n                content: message,\n                regenerate: !!options?.regenerate,\n              }),\n              signal,\n            },\n          );\n          if (res.status === 401 || res.status === 403) {\n            // Fall back to quick chat streaming\n          } else {\n            if (!res.ok || !res.body)\n              throw new Error(\"Streaming not available\");\n            const reader = res.body.getReader();\n            const decoder = new TextDecoder();\n            let buffer = \"\";\n            let full = \"\";\n            while (true) {\n              const { value, done } = await reader.read();\n              if (done) break;\n              buffer += decoder.decode(value, { stream: true });\n              let idx;\n              while ((idx = buffer.indexOf(\"\\n\\n\")) !== -1) {\n                const evt = buffer.slice(0, idx);\n                buffer = buffer.slice(idx + 2);\n                if (evt.startsWith(\"event: done\")) {\n                  // end of stream\n                  reader.cancel().catch(() => {\n                    /* swallow cancel error */\n                  });\n                  buffer = \"\";\n                  break;\n                }\n                const lines = evt.split(\"\\n\");\n                for (const line of lines) {\n                  if (line.startsWith(\"data: \")) {\n                    const piece = line.slice(6);\n                    full += piece;\n                    if (piece) options?.onToken?.(piece);\n                  }\n                }\n              }\n            }\n            const text = full.trim();\n            if (text.length > 0) return text;\n            throw new Error(\"Empty stream\");\n          }\n        } catch (e) {\n          // If aborted, return empty string (UI retains whatever was appended via onToken)\n          if (controllerRef.current && controllerRef.current.signal.aborted) {\n            return \"\";\n          }\n        }\n      }\n\n      // Quick chat fallback (no auth or failure): try SSE streaming via /api/ai/stream\n      try {\n        const res = await fetch(\"/api/ai/stream\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ prompt: message }),\n          signal,\n        });\n        if (!res.ok || !res.body) throw new Error(\"Streaming not available\");\n        const reader = res.body.getReader();\n        const decoder = new TextDecoder();\n        let buffer = \"\";\n        let full = \"\";\n        while (true) {\n          const { value, done } = await reader.read();\n          if (done) break;\n          buffer += decoder.decode(value, { stream: true });\n          let idx;\n          while ((idx = buffer.indexOf(\"\\n\\n\")) !== -1) {\n            const evt = buffer.slice(0, idx);\n            buffer = buffer.slice(idx + 2);\n            if (evt.startsWith(\"event: done\")) {\n              // end of stream\n              break;\n            }\n            const lines = evt.split(\"\\n\");\n            for (const line of lines) {\n              if (line.startsWith(\"data: \")) {\n                const piece = line.slice(6);\n                full += piece;\n                if (piece) options?.onToken?.(piece);\n              }\n            }\n          }\n        }\n        const text = full.trim();\n        if (text.length > 0) return text;\n        throw new Error(\"Empty stream\");\n      } catch (e) {\n        // If aborted, return empty string instead of throwing a toast error\n        if (controllerRef.current.signal.aborted) {\n          return \"\";\n        }\n        // Fallback to non-streaming JSON endpoint\n        const quick = await fetch(\"/api/ai\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ prompt: message }),\n        });\n        if (!quick.ok) {\n          let j: unknown = null;\n          try {\n            j = await quick.json();\n          } catch { /* ignore json parse errors */ }\n          const msg = extractErrorMessage(j, \"Failed to send message\");\n          throw new Error(msg);\n        }\n        let data: unknown = null;\n        try {\n          data = await quick.json();\n        } catch {\n          /* ignore json parse errors */\n        }\n        const reply = extractReply(data);\n        if (typeof reply === \"string\") {\n          if (reply) options?.onToken?.(reply);\n          return reply;\n        }\n        throw new Error(\"Invalid response\");\n      }\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to send message\";\n      setError(errorMessage);\n      toast.error(errorMessage);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const stop = (): void => {\n    if (controllerRef.current) {\n      try {\n        controllerRef.current.abort();\n      } catch {\n        /* ignore abort error */\n      }\n      controllerRef.current = null;\n      setLoading(false);\n    }\n  };\n\n  return {\n    loading,\n    error,\n    sendMessage,\n    conversationId,\n    resetConversation,\n    stop,\n    selectConversation,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Taliyo Tech\\sample\\sample 7 august\\GoalTracker AI\\src\\react-app\\hooks\\useCustomAuth.tsx","messages":[{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":67,"column":5,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":67,"endColumn":23,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[1713,1713],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[1713,1713],"text":"await "},"desc":"Add await operator."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useContext, createContext } from \"react\";\nimport toast from \"react-hot-toast\";\n\ninterface User {\n  id: string;\n  email?: string;\n  phone?: string;\n  name: string;\n  profile_image?: string;\n  is_email_verified: boolean;\n  is_phone_verified: boolean;\n}\n\ninterface AuthContextType {\n  user: User | null;\n  isLoading: boolean;\n  login: (credentials: { email: string; password: string }) => Promise<void>;\n  signup: (userData: {\n    email: string;\n    password: string;\n    name: string;\n  }) => Promise<void>;\n  logout: () => Promise<void>;\n  updateProfile: (data: Partial<User>) => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error(\"useAuth must be used within an AuthProvider\");\n  }\n  return context;\n};\n\ninterface AuthProviderProps {\n  children: React.ReactNode;\n}\n\ninterface ApiUserJson {\n  user?: User;\n  error?: unknown;\n}\n\nfunction extractErrorMessage(data: unknown, fallback: string): string {\n  if (data && typeof data === \"object\" && \"error\" in data) {\n    const err = (data as { error?: unknown }).error;\n    if (typeof err === \"string\") return err;\n  }\n  return fallback;\n}\n\nfunction extractUser(data: unknown): User | null {\n  if (data && typeof data === \"object\" && \"user\" in data) {\n    const u = (data as ApiUserJson).user;\n    if (u && typeof u === \"object\") return u;\n  }\n  return null;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    checkAuthStatus();\n  }, []);\n\n  const checkAuthStatus = async (): Promise<void> => {\n    try {\n      const response = await fetch(\"/api/auth/me\");\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch (err) {\n        console.warn(\"Invalid JSON from /api/auth/me\", err);\n      }\n      if (response.ok) {\n        const u = extractUser(data);\n        if (u) setUser(u);\n      }\n    } catch (error) {\n      console.error(\"Auth check failed:\", error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const login = async (credentials: {\n    email: string;\n    password: string;\n  }): Promise<void> => {\n    try {\n      const response = await fetch(\"/api/auth/login\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(credentials),\n      });\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch (err) {\n        console.warn(\"Invalid JSON from /api/auth/login\", err);\n      }\n      if (response.ok) {\n        const u = extractUser(data);\n        if (u) setUser(u);\n        toast.success(\"Logged in successfully!\");\n      } else {\n        const msg = extractErrorMessage(data, \"Login failed\");\n        throw new Error(msg);\n      }\n    } catch (error) {\n      console.error(\"Login failed:\", error);\n      toast.error(\"Login failed\");\n      throw error;\n    }\n  };\n\n  const signup = async (userData: {\n    email: string;\n    password: string;\n    name: string;\n  }): Promise<void> => {\n    try {\n      const response = await fetch(\"/api/auth/signup\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(userData),\n      });\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch (err) {\n        console.warn(\"Invalid JSON from /api/auth/signup\", err);\n      }\n      if (response.ok) {\n        const u = extractUser(data);\n        if (u) setUser(u);\n        toast.success(\"Account created successfully!\");\n      } else {\n        const msg = extractErrorMessage(data, \"Signup failed\");\n        throw new Error(msg);\n      }\n    } catch (error) {\n      console.error(\"Signup failed:\", error);\n      toast.error(\"Signup failed\");\n      throw error;\n    }\n  };\n\n  // Removed Google OAuth flow\n\n  const logout = async (): Promise<void> => {\n    try {\n      await fetch(\"/api/auth/logout\", { method: \"POST\" });\n      setUser(null);\n      toast.success(\"Logged out successfully\");\n    } catch (error) {\n      console.error(\"Logout failed:\", error);\n    }\n  };\n\n  const updateProfile = async (data: Partial<User>): Promise<void> => {\n    try {\n      const response = await fetch(\"/api/auth/profile\", {\n        method: \"PUT\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(data),\n      });\n      let body: unknown = null;\n      try {\n        body = await response.json();\n      } catch (err) {\n        console.warn(\"Invalid JSON from /api/auth/profile\", err);\n      }\n      if (response.ok) {\n        const u = extractUser(body);\n        if (u) setUser(u);\n        toast.success(\"Profile updated!\");\n      } else {\n        const msg = extractErrorMessage(body, \"Profile update failed\");\n        throw new Error(msg);\n      }\n    } catch (error) {\n      console.error(\"Profile update failed:\", error);\n      toast.error(\"Failed to update profile\");\n      throw error;\n    }\n  };\n\n  return (\n    <AuthContext.Provider\n      value={{\n        user,\n        isLoading,\n        login,\n        signup,\n        logout,\n        updateProfile,\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"D:\\Taliyo Tech\\sample\\sample 7 august\\GoalTracker AI\\src\\react-app\\hooks\\useDailyLogs.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"number\" of template literal expression.","line":153,"column":55,"nodeType":"MemberExpression","messageId":"invalidType","endLine":153,"endColumn":65},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":194,"column":5,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":194,"endColumn":17,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[5543,5543],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[5543,5543],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'fetchLogs' and 'isLoading'. Either include them or remove the dependency array.","line":195,"column":6,"nodeType":"ArrayExpression","endLine":195,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [depKey, fetchLogs, isLoading]","fix":{"range":[5561,5569],"text":"[depKey, fetchLogs, isLoading]"}}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from \"react\";\nimport { useAuth } from \"@/react-app/hooks/useCustomAuth\";\nimport type { DailyLog, CreateDailyLog, UpdateDailyLog } from \"@/shared/types\";\nimport toast from \"react-hot-toast\";\n\ninterface ApiErrorJson {\n  error?: unknown;\n}\ninterface DailyLogsResponseJson {\n  logs?: DailyLog[];\n}\ninterface LogResponseJson {\n  log?: DailyLog;\n}\n\nfunction extractErrorMessage(data: unknown, fallback: string): string {\n  if (data && typeof data === \"object\" && \"error\" in data) {\n    const err = (data as ApiErrorJson).error;\n    if (typeof err === \"string\") return err;\n  }\n  return fallback;\n}\n\nfunction extractLogs(data: unknown): DailyLog[] {\n  if (data && typeof data === \"object\" && \"logs\" in data) {\n    const logs = (data as DailyLogsResponseJson).logs;\n    if (Array.isArray(logs)) return logs;\n  }\n  return [];\n}\n\nfunction extractLog(data: unknown): DailyLog | null {\n  if (data && typeof data === \"object\" && \"log\" in data) {\n    const log = (data as LogResponseJson).log;\n    if (log && typeof log === \"object\") return log;\n  }\n  return null;\n}\n\nexport function useDailyLogs(date?: string): {\n  logs: DailyLog[];\n  loading: boolean;\n  error: string | null;\n  createOrUpdateLog: (logData: CreateDailyLog) => Promise<DailyLog>;\n  updateLog: (logData: UpdateDailyLog) => Promise<DailyLog>;\n  refetch: () => Promise<void>;\n} {\n  const [logs, setLogs] = useState<DailyLog[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const { user, isLoading } = useAuth();\n  // Constant-length dependency key: auth loading state + user id + date\n  const depKey = `${isLoading ? \"1\" : \"0\"}|${user?.id ?? \"\"}|${date ?? \"\"}`;\n\n  const fetchLogs = async (): Promise<void> => {\n    try {\n      // If not authenticated, treat as empty logs without error\n      if (!user) {\n        setLogs([]);\n        setError(null);\n        return;\n      }\n      setLoading(true);\n      const url = date ? `/api/daily-logs?date=${date}` : \"/api/daily-logs\";\n      const response = await fetch(url);\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch {\n        /* ignore json parse errors */\n      }\n      if (!response.ok) {\n        const msg = extractErrorMessage(data, \"Failed to fetch daily logs\");\n        if (response.status === 401 || msg === \"Unauthorized\") {\n          setLogs([]);\n          setError(null);\n          return;\n        }\n        throw new Error(msg);\n      }\n      setLogs(extractLogs(data));\n      setError(null);\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"An error occurred\";\n      setError(errorMessage);\n      toast.error(errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const createOrUpdateLog = async (\n    logData: CreateDailyLog,\n  ): Promise<DailyLog> => {\n    try {\n      const response = await fetch(\"/api/daily-logs\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(logData),\n      });\n\n      if (!response.ok) {\n        // Try to read error JSON safely\n        let data: unknown = null;\n        try {\n          data = await response.json();\n        } catch {\n          /* ignore json parse errors */\n        }\n        const msg = extractErrorMessage(data, \"Failed to save daily log\");\n        throw new Error(msg);\n      }\n\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch {\n        /* ignore json parse errors */\n      }\n      const saved = extractLog(data);\n      if (!saved) throw new Error(\"Invalid server response\");\n\n      // Update or add log in state\n      setLogs((prev) => {\n        const existingIndex = prev.findIndex(\n          (log) =>\n            log.goal_id === saved.goal_id && log.log_date === saved.log_date,\n        );\n\n        if (existingIndex >= 0) {\n          const updated = [...prev];\n          updated[existingIndex] = saved;\n          return updated;\n        } else {\n          return [...prev, saved];\n        }\n      });\n\n      return saved;\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to save daily log\";\n      toast.error(errorMessage);\n      throw err;\n    }\n  };\n\n  const updateLog = async (logData: UpdateDailyLog): Promise<DailyLog> => {\n    try {\n      const response = await fetch(`/api/daily-logs/${logData.id}`, {\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(logData),\n      });\n\n      if (!response.ok) {\n        let data: unknown = null;\n        try {\n          data = await response.json();\n        } catch {\n          /* ignore json parse errors */\n        }\n        const msg = extractErrorMessage(data, \"Failed to update daily log\");\n        throw new Error(msg);\n      }\n\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch {\n        /* ignore json parse errors */\n      }\n      const updated = extractLog(data);\n      if (!updated) throw new Error(\"Invalid server response\");\n      setLogs((prev) =>\n        prev.map((log) => (log.id === logData.id ? updated : log)),\n      );\n      return updated;\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to update daily log\";\n      toast.error(errorMessage);\n      throw err;\n    }\n  };\n\n  useEffect(() => {\n    if (isLoading) return; // wait for auth resolution\n    fetchLogs();\n  }, [depKey]);\n\n  return {\n    logs,\n    loading,\n    error,\n    createOrUpdateLog,\n    updateLog,\n    refetch: fetchLogs,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"D:\\Taliyo Tech\\sample\\sample 7 august\\GoalTracker AI\\src\\react-app\\hooks\\useGoals.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"number\" of template literal expression.","line":130,"column":50,"nodeType":"MemberExpression","messageId":"invalidType","endLine":130,"endColumn":61},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"number\" of template literal expression.","line":164,"column":50,"nodeType":"Identifier","messageId":"invalidType","endLine":164,"endColumn":56},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":170,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":170,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[5014,5014],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":187,"column":5,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":187,"endColumn":18,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[5530,5530],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[5530,5530],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'fetchGoals' and 'isLoading'. Either include them or remove the dependency array.","line":188,"column":6,"nodeType":"ArrayExpression","endLine":188,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [depKey, fetchGoals, isLoading]","fix":{"range":[5549,5557],"text":"[depKey, fetchGoals, isLoading]"}}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from \"react\";\nimport type { Goal, CreateGoal, UpdateGoal } from \"@/shared/types\";\nimport { useAuth } from \"@/react-app/hooks/useCustomAuth\";\nimport toast from \"react-hot-toast\";\n\ninterface ApiErrorJson {\n  error?: unknown;\n}\ninterface GoalsResponseJson {\n  goals?: Goal[];\n}\ninterface GoalResponseJson {\n  goal?: Goal;\n}\n\nfunction extractErrorMessage(data: unknown, fallback: string): string {\n  if (data && typeof data === \"object\" && \"error\" in data) {\n    const err = (data as ApiErrorJson).error;\n    if (typeof err === \"string\") return err;\n  }\n  return fallback;\n}\n\nfunction extractGoals(data: unknown): Goal[] {\n  if (data && typeof data === \"object\" && \"goals\" in data) {\n    const g = (data as GoalsResponseJson).goals;\n    if (Array.isArray(g)) return g;\n  }\n  return [];\n}\n\nfunction extractGoal(data: unknown): Goal | null {\n  if (data && typeof data === \"object\" && \"goal\" in data) {\n    const g = (data as GoalResponseJson).goal;\n    if (g && typeof g === \"object\") return g;\n  }\n  return null;\n}\n\nexport function useGoals(): {\n  goals: Goal[];\n  loading: boolean;\n  error: string | null;\n  createGoal: (goalData: CreateGoal) => Promise<Goal>;\n  updateGoal: (goalData: UpdateGoal) => Promise<Goal>;\n  deleteGoal: (goalId: number) => Promise<void>;\n  refetch: () => Promise<void>;\n} {\n  const [goals, setGoals] = useState<Goal[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const { user, isLoading } = useAuth();\n  // Constant-length dependency key: auth loading state + user id\n  const depKey = `${isLoading ? \"1\" : \"0\"}|${user?.id ?? \"\"}`;\n\n  const fetchGoals = async (): Promise<void> => {\n    try {\n      // If not authenticated, treat as empty goals without error\n      if (!user) {\n        setGoals([]);\n        setError(null);\n        return;\n      }\n      setLoading(true);\n      const response = await fetch(\"/api/goals\");\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch {\n        /* ignore json parse errors */\n      }\n      if (!response.ok) {\n        const msg = extractErrorMessage(data, \"Failed to fetch goals\");\n        // Silently handle unauthorized (e.g., expired session)\n        if (response.status === 401 || msg === \"Unauthorized\") {\n          setGoals([]);\n          setError(null);\n          return;\n        }\n        throw new Error(msg);\n      }\n      setGoals(extractGoals(data));\n      setError(null);\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"An error occurred\";\n      setError(errorMessage);\n      toast.error(errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const createGoal = async (goalData: CreateGoal): Promise<Goal> => {\n    try {\n      const response = await fetch(\"/api/goals\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(goalData),\n      });\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch {\n        /* ignore json parse errors */\n      }\n      if (!response.ok) {\n        const msg = extractErrorMessage(data, \"Failed to create goal\");\n        throw new Error(msg);\n      }\n      const newGoal = extractGoal(data);\n      if (!newGoal) {\n        throw new Error(\"Invalid server response\");\n      }\n      setGoals((prev) => [newGoal, ...prev]);\n      toast.success(\"Goal created successfully!\");\n      return newGoal;\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to create goal\";\n      toast.error(errorMessage);\n      throw err;\n    }\n  };\n\n  const updateGoal = async (goalData: UpdateGoal): Promise<Goal> => {\n    try {\n      const response = await fetch(`/api/goals/${goalData.id}`, {\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(goalData),\n      });\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch { /* ignore json parse errors */ }\n      if (!response.ok) {\n        const msg = extractErrorMessage(data, \"Failed to update goal\");\n        throw new Error(msg);\n      }\n      const updated = extractGoal(data);\n      if (!updated) {\n        throw new Error(\"Invalid server response\");\n      }\n      setGoals((prev) =>\n        prev.map((goal) => (goal.id === goalData.id ? updated : goal)),\n      );\n      toast.success(\"Goal updated successfully!\");\n      return updated;\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to update goal\";\n      toast.error(errorMessage);\n      throw err;\n    }\n  };\n\n  const deleteGoal = async (goalId: number): Promise<void> => {\n    try {\n      const response = await fetch(`/api/goals/${goalId}`, {\n        method: \"DELETE\",\n      });\n      let data: unknown = null;\n      try {\n        data = await response.json();\n      } catch {}\n      if (!response.ok) {\n        const msg = extractErrorMessage(data, \"Failed to delete goal\");\n        throw new Error(msg);\n      }\n      setGoals((prev) => prev.filter((goal) => goal.id !== goalId));\n      toast.success(\"Goal deleted successfully!\");\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : \"Failed to delete goal\";\n      toast.error(errorMessage);\n      throw err;\n    }\n  };\n\n  useEffect(() => {\n    if (isLoading) return; // wait for auth resolution\n    fetchGoals();\n  }, [depKey]);\n\n  return {\n    goals,\n    loading,\n    error,\n    createGoal,\n    updateGoal,\n    deleteGoal,\n    refetch: fetchGoals,\n  };\n}\n","usedDeprecatedRules":[]}]